# -*- coding: utf-8 -*-
"""riskAnalysisVar.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1upkDeYu91-dGv9AtovWVbLITREkjDedc

# Quantitative Risk Analysis with Value at Risk (VaR)

This project performs a comprehensive risk analysis of a portfolio using different Value at Risk (VaR) methods. We will compare the following methods:

- **Historical Simulation**: Calculates VaR based on historical data distribution.
- **Parametric VaR**: Uses the normal distribution of returns to compute VaR.
- **Monte Carlo Simulation**: Simulates price paths and estimates VaR using those simulations.

We will visualize the results for each method and compare them.
"""

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from scipy.stats import norm

"""### Step 1: Download Historical Data

We will use Yahoo Finance to download stock data for multiple assets in the portfolio. For this example, we will use Apple, Microsoft, and Tesla stocks.
"""

# Define tickers for the portfolio
tickers = ['AAPL', 'MSFT', 'TSLA']

# Download historical stock data for the past 2 years
data = yf.download(tickers, start="2023-01-01", end="2025-03-01")['Close']

# Calculate daily returns
returns = data.pct_change().dropna()

"""### Step 2: Compute Portfolio Returns

Assuming equal weights for the portfolio, we will calculate the overall portfolio returns.
"""

# Assuming equal weights for each stock in the portfolio
weights = np.ones(len(tickers)) / len(tickers)

# Compute portfolio daily returns
portfolio_returns = returns.dot(weights)

"""### Step 3: Calculate VaR Using Historical Simulation

VaR is calculated using the historical distribution of portfolio returns by taking the 5th percentile of the returns.
"""

# Historical Simulation VaR (1-day VaR at 95% confidence level)
historical_var = np.percentile(portfolio_returns, 5)  # 5th percentile for 95% confidence
print(f"Historical VaR (95% confidence): {historical_var * 100:.2f}%")

"""### Step 4: Calculate VaR Using Parametric Method

This method assumes that the returns of the portfolio follow a normal distribution. We will use the mean and standard deviation to compute VaR.
"""

# Parametric VaR (using the normal distribution)
mean_return = portfolio_returns.mean()
std_return = portfolio_returns.std()

# 1-day VaR at 95% confidence level (using the normal distribution)
parametric_var = norm.ppf(0.05, mean_return, std_return)  # 5th percentile of normal distribution
print(f"Parametric VaR (95% confidence): {parametric_var * 100:.2f}%")

"""### Step 5: Calculate VaR Using Monte Carlo Simulation

Here, we simulate random future price paths based on historical data and calculate the VaR based on these simulations.
"""

# Monte Carlo Simulation for VaR (1-day VaR at 95% confidence level)
num_simulations = 10000
simulated_returns = np.random.normal(mean_return, std_return, num_simulations)

# Calculate the 5th percentile (VaR at 95% confidence level)
monte_carlo_var = np.percentile(simulated_returns, 5)
print(f"Monte Carlo Simulation VaR (95% confidence): {monte_carlo_var * 100:.2f}%")

"""### Step 6: Visualize the Results

We will visualize the distribution of portfolio returns and the calculated VaR using each method.
"""

# Plotting the distribution of portfolio returns
plt.hist(portfolio_returns, bins=50, edgecolor='k', alpha=0.7)
plt.axvline(x=historical_var, color='r', linestyle='--', label=f"Historical VaR: {historical_var * 100:.2f}%")
plt.axvline(x=parametric_var, color='g', linestyle='--', label=f"Parametric VaR: {parametric_var * 100:.2f}%")
plt.axvline(x=monte_carlo_var, color='b', linestyle='--', label=f"Monte Carlo VaR: {monte_carlo_var * 100:.2f}%")

plt.title("Portfolio Returns Distribution and VaR")
plt.xlabel("Portfolio Daily Returns")
plt.ylabel("Frequency")
plt.legend()
plt.show()

"""# VaR using OOP

# Quantitative Risk Analysis with Value at Risk (VaR) - OOP Implementation

This notebook demonstrates the calculation of **Value at Risk (VaR)** for a portfolio using three methods:
- Historical Simulation
- Parametric VaR
- Monte Carlo Simulation

We will implement this analysis in an **Object-Oriented Programming (OOP)** style to keep the code modular, reusable, and scalable.
"""

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from scipy.stats import norm

"""### Step 1: Download Historical Data

We will use Yahoo Finance to download stock data for multiple assets in the portfolio. For this example, we will use Apple, Microsoft, and Tesla stocks.

"""

# Define tickers for the portfolio
tickers = ['AAPL', 'MSFT', 'TSLA']

# Download historical stock data for the past 2 years
data = yf.download(tickers, start="2023-01-01", end="2025-01-01")['Close']

# Calculate daily returns
returns = data.pct_change().dropna()

"""### Step 2: Define Portfolio and Create a Portfolio Class

We will define a **Portfolio** class to manage the assets and handle the portfolio returns calculation.
"""

class Portfolio:
    def __init__(self, tickers, weights=None):
        self.tickers = tickers
        self.weights = weights if weights else np.ones(len(tickers)) / len(tickers)
        self.data = None
        self.returns = None

    def fetch_data(self, start_date, end_date):
        """Fetch stock data from Yahoo Finance."""
        data = yf.download(self.tickers, start=start_date, end=end_date)['Close']
        self.data = data
        self.returns = data.pct_change().dropna()

    def portfolio_returns(self):
        """Calculate portfolio returns based on weights."""
        return self.returns.dot(self.weights)

"""### Step 3: Define a RiskModel Class

We will define a `RiskModel` class to calculate and visualize VaR using three different methods: Historical Simulation, Parametric VaR, and Monte Carlo Simulation.
"""

class RiskModel:
    def __init__(self, portfolio):
        self.portfolio = portfolio
        self.portfolio_returns = portfolio.portfolio_returns()

    def historical_var(self, confidence_level=0.05):
        """Calculate VaR using Historical Simulation."""
        return np.percentile(self.portfolio_returns, 100 * confidence_level)

    def parametric_var(self, confidence_level=0.05):
        """Calculate VaR using Parametric Method (Normal Distribution)."""
        mean_return = self.portfolio_returns.mean()
        std_return = self.portfolio_returns.std()
        return norm.ppf(confidence_level, mean_return, std_return)

    def monte_carlo_var(self, confidence_level=0.05, num_simulations=10000):
        """Calculate VaR using Monte Carlo Simulation."""
        mean_return = self.portfolio_returns.mean()
        std_return = self.portfolio_returns.std()
        simulated_returns = np.random.normal(mean_return, std_return, num_simulations)
        return np.percentile(simulated_returns, 100 * confidence_level)

    def visualize_var(self, historical, parametric, monte_carlo):
        """Visualize the VaR calculations."""
        plt.hist(self.portfolio_returns, bins=50, edgecolor='k', alpha=0.7)
        plt.axvline(x=historical, color='r', linestyle='--', label=f"Historical VaR: {historical * 100:.2f}%")
        plt.axvline(x=parametric, color='g', linestyle='--', label=f"Parametric VaR: {parametric * 100:.2f}%")
        plt.axvline(x=monte_carlo, color='b', linestyle='--', label=f"Monte Carlo VaR: {monte_carlo * 100:.2f}%")
        plt.title("Portfolio Returns Distribution and VaR")
        plt.xlabel("Portfolio Daily Returns")
        plt.ylabel("Frequency")
        plt.legend()
        plt.show()

"""### Step 4: Use OOP for Full Risk Analysis with Portfolio Data

We will instantiate the **Portfolio** and **RiskModel** classes to run the full risk analysis with VaR calculations.
"""

# Create a Portfolio object with stock tickers and weights
portfolio = Portfolio(tickers=['AAPL', 'MSFT', 'TSLA'], weights=[0.4, 0.3, 0.3])

# Fetch the stock data for the portfolio
portfolio.fetch_data('2023-01-01', '2025-03-01')

# Create a RiskModel object for VaR calculation
risk_model = RiskModel(portfolio)

# Calculate VaR using different methods
historical_var = risk_model.historical_var()
parametric_var = risk_model.parametric_var()
monte_carlo_var = risk_model.monte_carlo_var()

# Print VaR values
print(f"Historical VaR (95% confidence): {historical_var * 100:.2f}%")
print(f"Parametric VaR (95% confidence): {parametric_var * 100:.2f}%")
print(f"Monte Carlo VaR (95% confidence): {monte_carlo_var * 100:.2f}%")

# Visualize the VaR results
risk_model.visualize_var(historical_var, parametric_var, monte_carlo_var)

"""### Step 5: Deep Dive into Further Risk Measures

We can now calculate other risk measures such as **Conditional Value at Risk (CVaR)** and **Expected Shortfall (ES)** to assess the tail risk of our portfolio.

Additionally, we will consider introducing **stress testing** and **scenario analysis** to understand how our portfolio would perform under extreme market conditions.

Let's implement these advanced risk metrics in the next steps.
"""

class AdvancedRiskModel(RiskModel):
    def __init__(self, portfolio):
        super().__init__(portfolio)

    def conditional_var(self, confidence_level=0.05):
        """Calculate Conditional Value at Risk (CVaR)."""
        var = self.historical_var(confidence_level)
        return self.portfolio_returns[self.portfolio_returns <= var].mean()

    def expected_shortfall(self, confidence_level=0.05):
        """Calculate Expected Shortfall (ES) as the mean of losses beyond VaR."""
        return self.conditional_var(confidence_level)

# Implement the advanced risk metrics
advanced_risk_model = AdvancedRiskModel(portfolio)

# Calculate CVaR and Expected Shortfall
cvar = advanced_risk_model.conditional_var()
es = advanced_risk_model.expected_shortfall()

# Print the results
print(f"Conditional VaR (95% confidence): {cvar * 100:.2f}%")
print(f"Expected Shortfall (95% confidence): {es * 100:.2f}%")

"""### Step 6: Advanced Visualizations

We will now create visualizations for the Conditional VaR (CVaR) and Expected Shortfall (ES) to understand tail risks and potential market downturn scenarios.
"""

def visualize_risk_measures(cvar, es):
    """Visualize CVaR and ES with portfolio returns."""
    plt.hist(portfolio.portfolio_returns(), bins=50, edgecolor='k', alpha=0.7)
    plt.axvline(x=cvar, color='orange', linestyle='--', label=f"Conditional VaR: {cvar * 100:.2f}%")
    plt.axvline(x=es, color='purple', linestyle='--', label=f"Expected Shortfall: {es * 100:.2f}%")
    plt.title("Portfolio Returns Distribution with CVaR and Expected Shortfall")
    plt.xlabel("Portfolio Daily Returns")
    plt.ylabel("Frequency")
    plt.legend()
    plt.show()

# Visualize CVaR and ES
visualize_risk_measures(cvar, es)

"""# Value at Risk (VaR) Calculation and Portfolio Optimization

This notebook demonstrates the calculation of Value at Risk (VaR) for a portfolio of financial assets using three different methods: Historical VaR, Parametric VaR, and Monte Carlo VaR. The code provided allows for the analysis of various weight combinations for the assets in the portfolio, calculating and visualizing the VaR for each combination.

#### Key Features:
- **Data Fetching**: The `VaRCalculation` class fetches historical price data for a list of tickers using the `yfinance` library.
- **VaR Calculation**: The three different methods for calculating VaR are:
  1. **Historical VaR**: Based on historical returns and calculated using percentiles.
  2. **Parametric VaR**: Assumes a normal distribution of returns and calculates VaR using the mean and standard deviation.
  3. **Monte Carlo VaR**: Uses Monte Carlo simulation to generate a distribution of potential portfolio returns and calculates VaR from this simulated data.
- **Weight Optimization**: The class tries different weight combinations for the tickers in the portfolio (step size of 1%) to calculate the corresponding VaR values.
- **Visualization**: The results are displayed in tabular form and the best combinations (with the lowest VaR) are visualized using bar plots for comparison.

#### Example Usage:
The class `VaRCalculation` is initialized with the list of tickers, start date, and end date. It fetches the historical data, calculates VaR using all three methods, and displays the results in a sorted table along with visualizations for the best performing weight combinations.

### Key Metrics:
- **Historical VaR**: Value-at-risk based on historical returns.
- **Parametric VaR**: Value-at-risk assuming a normal distribution of returns.
- **Monte Carlo VaR**: Value-at-risk based on simulated returns from a Monte Carlo simulation.

### class VaRCalculation with min_weight, max_weight, step size
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from scipy.stats import norm

# Class to calculate and visualize VaR (Value at Risk)
class VaRCalculation:
    def __init__(self, tickers, start_date, end_date):
        self.tickers = tickers
        self.start_date = start_date
        self.end_date = end_date
        self.data = None
        self.weights = None

    def fetch_data(self):
        """Fetch historical data for tickers"""
        self.data = yf.download(self.tickers, start=self.start_date, end=self.end_date)['Close']
        self.data = self.data.pct_change().dropna()  # Daily returns

    def calculate_var(self, weights, var_type='parametric'):
        """Calculate Value at Risk based on specified type"""
        # Weighted returns for the portfolio
        portfolio_returns = np.dot(self.data, weights)

        if var_type == 'historical':
            return self.calculate_historical_var(portfolio_returns)
        elif var_type == 'parametric':
            return self.calculate_parametric_var(portfolio_returns)
        elif var_type == 'monte_carlo':
            return self.calculate_monte_carlo_var(portfolio_returns)

    def calculate_historical_var(self, portfolio_returns, confidence_level=0.95):
        """Calculate Historical VaR"""
        var = np.percentile(portfolio_returns, (1 - confidence_level) * 100)
        return var

    def calculate_parametric_var(self, portfolio_returns, confidence_level=0.95):
        """Calculate Parametric VaR using normal distribution"""
        mean = np.mean(portfolio_returns)
        std_dev = np.std(portfolio_returns)
        var = mean + norm.ppf(1 - confidence_level) * std_dev
        return var

    def calculate_monte_carlo_var(self, portfolio_returns, num_simulations=10000, confidence_level=0.95):
        """Calculate VaR using Monte Carlo simulation"""
        simulations = np.random.choice(portfolio_returns, (num_simulations, len(portfolio_returns)))
        simulated_returns = simulations.mean(axis=1)
        var = np.percentile(simulated_returns, (1 - confidence_level) * 100)
        return var

    def try_all_combinations(self, min_weight=0.01, max_weight=1.0, step=0.01, confidence_level=0.95):
        """Test all possible weight combinations and calculate VaR for each"""
        results = []

        # Generate all weight combinations for 3 assets
        num_assets = len(self.tickers)  # Get the number of assets

        # Iterate through possible weight combinations, ensuring they sum to 1
        for i in np.arange(min_weight, max_weight, step):
            for j in np.arange(min_weight, max_weight, step):
                if (i + j) < 1: # Check if the sum of weights is less than 1
                    k = 1- (i+j) # Calculate the weight for the third asset
                    if k >= min_weight and k <= max_weight:
                        weights = [i, j, k]
                        historical_var = self.calculate_var(weights, var_type='historical')
                        parametric_var = self.calculate_var(weights, var_type='parametric')
                        monte_carlo_var = self.calculate_var(weights, var_type='monte_carlo')
                        results.append((weights[0], weights[1], weights[2], historical_var, parametric_var, monte_carlo_var))

        # Convert results to DataFrame
        results_df = pd.DataFrame(results, columns=["Weight (Ticker 1)", "Weight (Ticker 2)", "Weight (Ticker 3)", "Historical VaR", "Parametric VaR", "Monte Carlo VaR"])
        results_df.sort_values(by="Historical VaR", ascending=True, inplace=True)
        print("Results (Sorted by Historical VaR):")
        print(results_df.head(10))  # Display top 10 results

        # Plot the two best VaR combinations
        self.plot_best_var_combinations(results_df)

    def plot_best_var_combinations(self, results_df):
        """Plot the best VaR combinations"""
        best_combination = results_df.iloc[0]

        # Get the best weight and VaR values
        best_weight = best_combination['Weight (Ticker 1)']
        historical_var = best_combination['Historical VaR']
        parametric_var = best_combination['Parametric VaR']
        monte_carlo_var = best_combination['Monte Carlo VaR']

        # Plot the results
        plt.figure(figsize=(10, 6))
        # annonate this plot

        plt.bar(['Historical VaR', 'Parametric VaR', 'Monte Carlo VaR'],
                [historical_var, parametric_var, monte_carlo_var], color='skyblue')
        plt.title(f'VaR Comparison for Best Weight Combination (Weight = {best_weight:.2f})')
        # annotate this plt values
        plt.text(0, historical_var, f'Historical VaR: {historical_var:.2f}', ha='center', va='bottom')
        plt.text(1, parametric_var, f'Parametric VaR: {parametric_var:.2f}', ha='center', va='bottom')
        plt.text(2, monte_carlo_var, f'Monte Carlo VaR: {monte_carlo_var:.2f}', ha='center', va='bottom')
        plt.xlabel('VaR Methods')
        plt.ylabel('VaR')
        plt.show()

# Example usage
tickers = ['AAPL', 'GOOG', 'TSLA']
start_date = '2019-01-01'
end_date = '2025-03-01'

# Instantiate the VaRCalculation class
var_calc = VaRCalculation(tickers, start_date, end_date)
var_calc.fetch_data()  # Fetch the data

# Try all weight combinations and calculate VaR for each
var_calc.try_all_combinations(min_weight=0.01, max_weight=1.0, step=0.05)

